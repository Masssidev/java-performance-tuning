# synchronized는 제대로 알고 써야 한다
우리가 개발하는 WAS는 여러 개의 스레드가 동작하도록 되어 있다. 그래서 synchronized를 자주 사용한다. 하지만 synchronized를 쓴다고 무조건 안정적인 것은
 아니며, 성능에 영향을 미치는 부분도 있다.
 <hr/>
 
 ### 프로세스와 스레드
 클래스를 하나 수행시키거나 WAS를 가동하면, 서버에 자바 프로세스가 하나 생성된다. 하나가 생성되는지 여러 개가 생성되는지는 윈도의 자원관리자나 
 리눅스, 유닉스의 프로세스를 조회해 보면 된다.
 
 하나의 프로세스에는 여러 개의 스레드가 생성된다. 단일 스레드가 생성되어 종료될 수도 있고, 여러 개의 스레드가 생성되어 수행될 수도 있다.
 그러므로 프로세스와 스레드의 관계는 1:多 관계라고 보면 된다. 스레드는 다른 말로 Lightweight Process(LWP)라고도 한다. 즉 가벼운 프로세스이고, 
 프로세스에서 만들어 사용하고 있는 메모리를 공유한다. 그래서 별개의 프로세스가 하나씩 뜨는 것보다는 성능이나 자원 사용에 있어서 많은 도움이 된다. 
 
 ##### Thread 클래스 상속과 Runnable 인터페이스 구현
 스레드의 구현은 Thread 클래스를 상속받는 방법과 Runnable 인터페이스를 구현하는 방법 두 가지가 있다. 어느 것을 사용해도 거의 차이가 없지만, 
 Runnable 인터페이스를 구현하면 원하는 기능을 추가할 수 있다. 또한 자바는 다중 상속을 인정하지 않아 스레드를 사용해야 할 때 이미 상속받은 클래스가
  존재한다면 Runnable 인터페이스를 구현해야 한다.
  
실행 소스
```
public class RunThreads {
  public static void main(String[] args) {
    RunnableImpl ri = new RunnableImpl();
    ThreadExtends te = new ThreadExtends();
    new Thread(ri).start();
    te.start();
  }
}
```
##### sleep(), wait(), join() 메서드
현재 진행 중인 스레드를 대기하도록 하기 위해서 쓰는 세 가지 메서드다.<br/>
* wait() 메서드는 모든 클래스의 부모 클래스인 Object 클래스에 선언되어 있으므로 어떤 클래스에서도 사용할 수 있다.
* 이 세 가지 메서드는 모두 예외를 던지도록 되어 있어 사용할 때는 반드시 예외 처리를 해주어야 한다.
* sleep() 메서드는 명시된 시간만큼 해당 스레드를 대기시킨다. 
    * sleep(long millis): 명시된 ms만큼 해당 스레드가 대기한다. static 메서드이기 때문에 반드시 스레드 객체를 통하지 않아도 사용할 수 있다.
    * sleep(long millis, int nanos): 명시된 ms + 명시된 나노 시간만큼 해당 스레드가 대기한다. 여기서 나노 시간은 0~999999까지 사용할 수 있다.
    이 메서드도 위와 마찬가지로 static 메서드다.
* wait() 메서드도 명시된 시간만큼 해당 스레드를 대기시킨다. sleep() 메서드와 다른 점은 매개변수인데, 만약 아무런 매개변수를 지정하지 않으면 
notify() 메서드 혹은 notifyAll() 메서드가 호출될 때까지 대기한다. 
* join() 메서드는 명시된 시간만큼 해당 스레드가 죽기를 기다린다. 만약 아무런 매개변수를 지정하지 않으면 죽을 때까지 계속 대기한다.

##### interrupt(), notify(), notifyAll() 메서드
앞서 명시한 세 개의 메서드를 '모두' 멈출 수 있는 유일한 메서드는 interrupt() 메서드다. interrupt()메서드가 호출되면 중지된 스레드에는 InterruptedException이 발생한다. 제대로 수행되었는지 확인하려면 interrupted()메서드를 호출하거나 isInterrupted()메서드를 호출하면 된다.
두 방법의 차이는 interrupted()메서드는 스레드의 상태를 변경시키지만, isInterrupted()메서드는 단지 스레드의 상태만을 리턴한다는 점이다.

추가로 isAlive()메서드라는 것이 있는데, 이는 해당 스레드가 살아있는지 확인하는 메서드다. 살아있다면 true를, 그렇지 않으면 false를 리턴한다.

notify()메서드와 notifyAll()메서드는 모두 wait()메서드를 멈추기 위한 메서드다. 이 두 메서드는 Object 클래스에 정의되어 있는데, wait() 메서드가
 호출된 후 대기 상태로 바뀐 스레드를 깨운다. notify()메서드는 객체의 모니터와 관련 있는 단일 스레드를 깨우며, notifyAll() 메서드는 객체의 모니터와 관련 있는 모든 스레드를 깨운다.
 <hr/>
 
 ##### interrupt() 메서드는 절대적인 것이 아니다
 interrupt()메서드를 호출하여 특정 메서드를 중지시키려고 할 때 항상 해당 메서드가 멈추는 것은 아니다. interrupt() 메서드는 해당 스레드가 'block'되거나 특정 상태에서만 작동한다. 
 > interrupt()메서드는 대기 상태일 때에만 해당 스레드를 중단시킨다.
 
<hr/>

### synchronized를 이해하자
synchronize 동사: 동시에 일어나다. 동시에 진행하다.<br/>
> synchronized는 하나의 객체에 여러 객체가 동시에 접근하여 처리하는 상황이 발생할 때 사용한다.<br/>
> "천천히 한 명씩 들어와!"

synchronized는 메서드와 블록으로 사용할 수 있다.
```
public synchronized void sampleMethod() {
 //중간생략
}

private object obj = new object();
public void sampleBlock() {
 synchronized(obj) {
  //중간 생략
 }
}
```
> 간단히 synchronized라는 식별자만 쓰면 동기화할 수 있다. <br/>
> * 메서드를 동기화하려면 메서드 선언부에 사용하면 된다.<br/>
> * 특정 부분을 동기화하려면 해당 블록에만 선언을 해서 사용하면 된다.<br/>

###### 언제 동기화를 해야 할까?
* 하나의 객체를 여러 스레드에서 동시에 사용할 경우
* static으로 선언한 객체를 여러 스레드에서 동시에 사용할 경우

> synchronized사용 시 응답시간이 많이 증가한다. 그러므로 반드시 필요한 부분에만 동기화를 사용해야 이러한 성능 저하를 줄일 수 있다.
<hr/>

### 동기화를 위해서 자바에서 제공하는 것들
java.util.concurrent 패키지 주요 개념
* Lock: 실행 중인 스레드를 간단한 방법으로 정지시켰다가 실행시킨다. 상호 참조로 인해 발생하는 데드락을 피할 수 있다.
* Executors: 스레드를 더 효율적으로 관리할 수 있는 클래스들을 제공한다. 스레드 풀도 제공하므로, 필요에 따라 유용하게 사용할 수 있다.
* Concurrent 콜렉션: 앞서 살펴본 콜렉션의 클래스들을 제공한다.
* Atomic 변수: 동기화가 되어 있는 변수를 제공한다. 이 변수를 사용하면, synchronized 식별자를 메서드에 지정할 필요 없이 사용할 수 있다.
> 더 편하게 스레드를 처리하고 싶다면 여기에 정의된 클래스를 사용하면 된다.
<hr/>

### JVM 내에서 synchronization은 어떻게 동작할까?
자바의 HotSpot VM은 '자바 모니터'를 제공함으로써 스레드들이 '상호 배제 프로토콜'에 참여할 수 있도록 돕는다. 자바 모니터는 잠긴 상태나 풀림중 하나이며, 동일한 모니터에 진입한 여러 스레드들 중에서 한 시점에는 단 하나의 스레드만 모니터를 가질 수 있다. 다시 말하면, 모니터를 가진 스레드만 모니터에 의해서 보호되는 영역에 들어가서 작업을 할 수 있다. 여기서 보호된 영역이란 이 장에서 앞서 설명한 synchronized로 감싸진 블록들을 의미한다. 모니터를 보유한 스레드가 보호 영역에서의 작업을 마치면, 모니터는 다른 대기중인 스레드에게 넘어간다.
