# JVM은 도대체 어떻게 구동될까?

### HotSpot VM은 어떻게 구성되어 있을까?
HotSpot이라는 단어는 일반적으로 붙여 사용하지 않고, Hot Spot이라는 숙어로 사용된다. 이 단어를 자바에서 HotSpot이라는 한 단어로 쓰이며, 정확한 명칭은 
'Java HotSpot Performance Engine'이다.

자바를 만든 Sun에서는 자바의 성능을 개선하기 위해서 Just In Time(JIT) 컴파일러를 만들었고, 이름을 HotSpot으로 지었다. 여기서 JIT 컴파일러는 프로그램의 
성능에 영향을 주는 지점에 대해서 지속적으로 분석한다. 분석된 지점은 부하를 최소화하고, 높은 성능을 내기 위한 최적화의 대상이 된다.

> 이 HotSpot은 자바 1.3 버전부터 기본 VM으로 사용되어 왔기 때문에, 지금 운영 되고 있는 대부분의 시스템들은 모두 HotSpot 기반의 VM이라고 생각하면 된다.

###### HotSpot VM의 세 가지 주요 컴포넌트
* VM(Virtual Machine) 런타임
* JIT(Just In Time) 컴팡일러
* 메모리 관리자<br/>
> HotSpot VM은 높은 성능과 확장성을 제공한다. 일례로 JIT 컴팡일러는 자바 애플리케이션이 수행되는 상황을 보고 동적으로 최적화를 수행한다.

※ JIT는 우리나라말로 하면 '적절한 시간'이라는 의미다. JIT를 사용한다는 것은 '언제나 자바 메서드가 호출되면 바이트 코드를 컴파일하고 실행 가능한 
네이티브 코드로 변환한다'는 의미다. 하지만, 매번 JIT로 컴파일을 하면 성능 저하가 심하므로, 최적화 단계를 거치게 된다.
<hr/>

### JIT Optimizer라는 게 도대체 뭘까?
컴파일이라는 작업은 상위 레벨의 언어로 만들어진 기계에 의존적인 코드로 변환하는 것을 말한다.<br/>

자바는 javac라는 컴파일러를 사용한다. 이 컴파일러는 소스코드를 바이트 코드로 된 class라는 파일로 변환해준다. 그렇기 때문에 JVM은 항상 바이트 코드로 
시작하며, 동적으로 기계에 의존적인 코드로 변환한다.

JIT는 애플리케이션에서 각각의 메서드를 컴파일할 만큼 시간적 여유가 많지 않다. 그러므로, 모든 코드는 초기에 인터프리터에 의해서 시작되고, 해당 코드가 충분히 
많이 사용될 경우에 컴파일할 대상이 된다. HotSpot VM에서 이 작업은 각 메서드에 있는 카운터를 통해서 통제되며, 메서드에는 두 개의 카운터가 존재한다.
* 수행 카운터(invocation counter): 메서드를 시작할 때마다 증가
* 백에지 카운터(backedge counter): 높은 바이트 코드 인덱스에서 낮은 인덱스로 컨트롤 흐름이 변경될 때마다 증가

> 여기서 백에지 카운터는 메서드가 루프가 존재하는지를 확인할 때 사용되며, 수행 카운터 보다 컴파일 우선순위가 높다.

> 이 카운터들이 인터프리터에 의해서 증가될 때마다, 그 값들이 한계치에 도달했는지를 확인하고, 도달했을 경우 인터프리터는 컴파일을 요청한다.

> 여기서 수행 카운터에서 사용하는 한계치는 CompileThreshold이며, 벡에지 카운터에서 사용하는 한계치는 다음의 공식으로 계산한다.
  * CompileThreshold * OnStackReplacePercentage / 100
 
> 이 두 개의 값을은 JVM이 시작할 때 지정 가능하며 다음과 같이 시작 옵션에 지정할 수 있다.
  * XX:CompileThreshold=35000
  * XX:OnStackReplacePercentage=80<br/>
> 즉, 이렇게 지정하면, 메서드가 3만 5천 번 호출되었을 때 JIT에서 컴파일을 하며, 백에지 카운터가 35,000 * 80 / 100 = 28,000이 되었을 때 컴파일된다.

컴파일이 요청되면 컴파일 대상 목록의 큐에 쌓이고, 하나 이상의 컴파일러 스레드가 이 큐를 모니터링한다. 만약 컴파일러 스레드가 바쁘지 않을 때는 큐에서 대상을 
빼내서 컴파일을 시작한다. 보통 인터프리터는 컴파일이 종료되기를 기다리지 않는 대신, 수행 카운터를 리셋하고 인터프리터에서 메서드 수행을 계속 한다. 
컴파일이 종료되면, 컴파일된 코드와 메서드가 연결되어 그 이후부터는 메서드가 호출되면 컴파일된 코드를 사용하게 된다. 만약 인터프리터에서 컴파일이 
종료될 때까지 기다리도록 하려면, JVM 시작시 -Xbatch나 -XX:BackgroundCompilation 옵션을 지정하여 컴파일을 기다리도록 할 수도 있다.

HotSpot VM은 OSR(On Stack Replacement)이라는 특별한 컴파일도 수행한다. 이 OSR은 인터프리터에서 수행한 코드 중 오랫동안 루프가 지속되는 경우에 
사용된다. 만약 해당 코드의 컴파일이 완료된 상태에서 최적화되지 않은 코드가 수행되고 있는 것을 발견한 경우에 인터프리터에 계속 머무르지 않고 컴파일된 
코드로 변경한다. 이 작업은 인터프리터에서 시작된 오랫동안 지속되는 루프가 다시는 불리지 않을 경우엔 도움이 되지 않지만, 루프가 끝나지 않고 지속적으로 
수행되고 있을 경우에는 큰 도움이 된다.
<hr/>

### JRockit의 JIT 컴파일 및 최적화 절차
* JRockit runs JIT compilation
  * 자바 애플리케이션을 실행하면 기본적으로는 1번 단계인 JIT 컴파일을 거친 후 실행이 된다. 이 단계를 거친 후 메서드가 수행되면, 그 다음부터는 컴파일 된 
  코드를 호출하기 때문에 처리 성능이 빨라진다.
  > JIT를 사용하면 시작할 때의 성능은 느리겠지만, 지속적으로 수행할 때는 더 빠른 처리가 가능하다.<br/>
  > 따라서, 모든 메서드를 컴파일하고 최적화하는 작업은 JVM 시작 시간을 느리게 만들기 때문에 시작할 때는 모든 메서드를 최적화하지는 않는다.

* JRockit monitors threads
  * JRockit에는 'sampler thread'라는 스레드가 존재하며 주기적으로 애플리케이션의 스레드를 점검한다. 이 스레드는 어떤 스레드가 동작 중인지 여부와 
  수행 내역을 관리한다. 이 정보들을 통해서 어떤 메서드가 많이 사용되는지를 확인하여 최적화 대상을 찾는다.
  
* JRockti JVM Runs Optimization
  * 'sampler thread'가 식별한 대상을 최적화한다. 이 작업은 백그라운드에서 진행되며 수행중인 애플리케이션에 영향을 주지는 않는다.
 <hr/>
 
### IBM JVM의 JIT 컴파일 및 최적화 절차
IBM JVM의 JIT 컴파일 방식
* 인라이닝
  * 메서드가 단순할 때 적용되는 방식이며, 호출된 메서드가 단순할 경우 그 내용이 호출한 메서드의 코드에 포함해 버린다. 이렇게 될 경우 자주 호출되는 
  메서드의 성능이 향상된다는 장점이 있다.
* 지역 최적화
  * 작은 단위의 코드를 분석하고 개선하는 작업을 수행한다.
* 조건 구문 최적화
  * 메서드 내의 조건 구문을 최적화하고, 효율성을 위해서 코드의 수행 경로를 변경한다
* 글로벌 최적화
  * 메서드 전체를 최적화하는 방식이다. 매우 비싼 방식이며, 컴파일 시간이 많이 소요된다는 단점이 있지만, 성능 개선이 많이 될 수 있다는 장점이 있다.
* 네이티브 코드 최적화
  * 이 방식은 플랫폼 아키텍처에 의존적이다. 다시 말해서 아키텍처에 따라서 최적화를 다르게 처리하는 것을 말한다.
 
 > 컴파일된 코드는 '코드 캐시'라고 하는 JVM 프로세스 영역에 저장된다. 결과적으로 JVM 프로세스는 JVM 수행 파일과 컴파일된 JIT 코드의 집합으로 구분된다.
 <hr/>
 
 ### JVM이 시작할 때의 절차는 이렇다
 1. 
