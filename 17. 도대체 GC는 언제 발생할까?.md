# 도대체 GC는 언제 발생할까?
유닉스나 리눅스 서버든 윈도 기반의 서버든 풀(Full)GC를 수행하는 시점에는 해당 JVM에서 처리되지 않는다는 단점이 있다. 다시 이야기하면 GC를 많이 하면 할수록 을답 
시간에 많은 영향을 끼친다.
<hr/>

### GC란?
자바에서는 메모리를 GC라는 알고리즘을 통하여 관리하기 때문에, 개발자가 메모리를 처리하기 위한 로직을 만들 필요가 없고, 절대로 만들어서는 안 된다.

Garabage Collection는 말 그대로 쓰레기를 정리하는 작업이다. 자바 프로그래밍을 할 때 쓰레기란 객체이다. 하나의 객체는 메모리를 점유하고, 필요하지 않으면 
메모리에서 해제되어야 한다. 메모리 점유는 다음과 같이 쉽게 할 수 있다. 이러한 코드에서는 a라는 객체가 만들어져 메모리의 한 부부을 점유하게 된다.
```
String a = new String();
```

> 더 이상 필요가 없는 객체 = 쓰레기 객체 <br/>
> 이 쓰레기 객체를 효과적으로 처리하는 작업을 GC라고 한다.
<hr/>

### 자바의 Runtime data area
자바에서 사용하는 메모리 영역
* PC 레지스터
* JVM 스택
* 힙(Heap)
* 메서드 영역
* 런타임 상수(constant) 풀
* 네이티브 메서드 스택<br/>
> 이 영역 중에서 GC가 발생하는 부분이 바로 힙 영역이다.<br/>

> 자바의 메모리 영역은 'Heap 메모리'와 'Non-heap 메모리'로 나뉜다.
* Heap 메모리
  * 클래스 인스턴스, 배열이 이 메모리에 쌓인다. 이 메모리는 '공유 메모리'라고도 불리우며 여러 스레드에서 공유하는 데이터들이 저장되는 메모리다.
* Non-heap 메모리
  * 이 메모리는 자바의 내부 처리를 위해서 필요한 영역이다. 여기서 주된 영역이 바로 메서드 영역이다.
    * 메서드 영역: 메서드 영역은 모든 JVM 스레드에서 공유한다. 이 영역에 저장되는 데이터들은 다음과 같다.<br/>
        ㅁ 런타임 상수 풀: 자바의 클래스 파일에는 contant_pool이라는 정보가 포함되어 있다. 이 contant_pool에 대한 정보를 실행 시에 참조하기 위한 영역이다.
     실제 상수 값도 여기에 포함될 수 있지만, 실행 시에 변하게 되는 필드 참조 정보도 포함된다.<br/>
        ㅁ 필드 정보에는 메서드 데이터, 메서드와 생성자 코드가 있다.
     * JVM 스택: 스레드가 시작할 때 JVM 스택이 생성된다. 이 스택에는 메서드가 호출되는 정보인 프레임이 저장된다. 그리고, 지역 변수와 임시 결과, 메서드 
     수행과 리턴에 관련된 정보들도 포함된다.
     * 네이티브 메서드 스택: 자바 코드가 아닌 다른 언어로 된 코드들이 실행하게 될 때의 스택 정보를 관리한다.
     * PC 레지스터: 자바의 스레드들은 각자의 pc(Program Counter) 레지스터를 갖는다. 네이티브한 코드를 제외한 모든 자바 코드들이 수행될 때 JVM의 
     인스트럭션 주소를 pc 레지스터에 보관한다.
 
 > 여기서 Heap 영역과 메서드 영역은 JVM이 시작될 때 생성된다.
 <hr/>
 
 ### GC의 원리
 GC 작업을 하는 가비지 콜렉터의 역할
 * 메모리 할당
 * 사용 중인 메모리 인식
 * 사용하지 않는 메모리 인식
 
 > 사용하지 않는 메모리를 인식하는 작업을 수행하지 않으면, 할당한 메모리 영역이 꽉차서 JVM에 행(Hang)이 걸리거나, 더 많은 메모리를 할당하려는 현상이 발생할 것이다.
 만약 JVM의 최대 메모리 크기를 지정해서 전부 사용한 다음, GC를 해도 더 이상 사용 가능한 메모리 영역이 없는데 계속 메모리를 할당하려고 하면 OutOfMemoryError가 발생하여 
 JVM가 다운될 수도 있다.<br/>
 ※ 행(Hang)이란 서버가 요청을 처리 못하고 있는 상태
 
 ###### 자바의 메모리 영역
 크게 Young, Old, Perm 세 영역으로 나뉜다. 이 중 Perm(Permanent) 영역은 없는 걸로 치자. 이 영역은 거의 사용이 되지 않는 영역으로 클래스와 메서드 정보와 
 같이 자바 언어 레벨에서 사용하는 영역이 아니기 때문이다. 게다가 JDK 8부터는 이 영역이 사라진다.
 
 Young 영역은 다시 Eden 영역 및 두 개의 Survivor 영역으로 나뉘므로 우리가 고려해야 할 자바의 메모리 영역은 총 4개 영역으로 나뉜다.
 * Young 영역
    * Eden
    * Survivor 1
    * Survivor 2
 * Old 영역
    * 메모리 영역
    
  일단 메모리에 객체가 생성되면 Eden 영역에 객체가 지정된다. Eden 영역에 데이터가 꽉 차면, 이 영역에 있던 객체가 어디론가 옮겨지거나 삭제되어야 한다. 
  이 때 옮겨 가는 위치가 Survivor 영역이다. 위에서는 구분을 하기 위해서 1과 2로 나눈 것 뿐이며, 두 개의 Survivor 영역 사이에 우선 순위가 있는 것은 아니다. 
  이 두 개의 영역 중 한 영역은 반드시 비어 있어야 한다. 그 비어 있는 영역에 Eden 영역에 있던 객체 중 GC 후에 살아 남아 있는 객체들이 이동한다. 할당된 
  Survivor 영역이 차면, GC가 되면서 Eden 영역에 있는 객체와 꽉 찬 Survivor 영역에 있는 객체가 비어 있는 Survivor 영역으로 이동한다. 이러한 작업을 
  반복하면서, Survivor 1과 2를 왔다 갔다 하던 객체들은 Old 영역으로 이동한다.
  
  그리고, Young 영역에서 Old 영역으로 넘어가는 객체 중 Survivor 영역을 거치지 않고 바로 Old 영역으로 이동하는 객체가 있을 수 있다. 객체의 크기가 아주 
  큰 경우인데, 예를 들어 Survivor 영역의 크기가 16MB인데 20MB를 점유하는 객체가 Eden 영역에서 생성되면 Survivor 영역으로 옮겨갈 수가 없다. 이런 객체들은 
  바로 Old 영역으로 이동하게 된다.
  <hr/>
  
  ### GC의 종류
  
  
    
