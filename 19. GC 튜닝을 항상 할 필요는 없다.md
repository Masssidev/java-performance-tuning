# GC 튜닝을 항상 할 필요는 없다
Java 기반의 모든 서비스에서 GC 튜닝을 진행할 필요는 없다.<br/>
전제 조건
* -Xml 옵션과 -Xmx 옵션으로 메모리 크기를 지정했다.
* -server 옵션이 포함되어 있다.
* DB 작업과 관련된 타임아웃 로그가 남아있지 않다.
* 다른 서버와의 통신시 타임아웃 로그가 남아 있지 않다.

> 즉, JVM의 메모리 크기도 지정하지 않았고, Timeout이 지속적으로 발생하고 있다면 GC튜닝을 하는 것이 좋다.

###### Old 영역으로 넘어가는 객체의 수 최소화하기
Old 영역으로 이동하는 객체의 수를 줄여 Full GC가 발생하는 빈도를 많이 줄인다.

###### Full GC 시간 줄이기
Full GC의 수행 시간은 상대적으로 Young GC에 비하여 길다. Full GC 실행에 시간이 오래 소요되면 연계된 여러 부분에서 타임아웃이 발생할 수 있다. 그렇다고 Full GC 
실행 시간을 줄이기 위해서 Old 영역의 크기를 줄이면 OutOfMemoryError가 발생하거나 Full GC 횟수가 늘어난다. 따라서 Old 영역의 크기를 '잘' 설정해야 한다.
<hr/>

### GC의 성능을 결정하는 옵션들
* 힙 영역 크기

옵션 | 설명
:------:|:-------:
-Xms | JVM 시작 시 힙 영역 크기
-Xmx | 최대 힙 영역 크기
* New 영역의 크기

옵션 | 설명
:------:|:-------:
-XX:NewRatio | New영역과 Old 영역의 비율
-XX:NewSize | New영역의 크기
-XX:SurvivorRatio | Eden영역과 Survivor 영역의 비율
###### GC 방식 옵션
* Serial GC

옵션 |
:------:|
-XX:+UseSerialGC |

* Parallel GC

옵션 |
:------:|
-XX:+UseParallelGC |
-XX:ParallelGCThreads=value |

* Parallel Compacting GC

옵션 |
:------:|
-XX:+UseParallelOldGC |

* CMS GC

옵션 |
:------:|
-XX:+UseConcMarkSweepGC |
-XX:+UseParNewGC |
-XX:+CMSParallelRemarkEnabled |
-XX:CMSInitiatingOccupancyFraction=value |
-XX:+UseCMSInitiatingOccupancyOnly |

* G1

옵션 | 비고
:------:|:--------:
-XX:+UseUnlockExperimentalVMOptions | JDK 6에서는 두 옵션을 반드시 같이 사용해야 함
-XX:+Use | JDK 6에서는 두 옵션을 반드시 같이 사용해야 함

> G1 GC를 제외하고는, 각 GC 방식의 첫 번째 줄에 있는 옵션을 지정하면 GC 방식이 변경된다. GC 방식 중에서 특별히 신경 쓸 필요가 없는 방식은 Serial GC다.
 Serial GC는 클라이언트 장비에 최적화되어 있기 때문이다.
 <hr/>
 
 ### GC 튜닝의 절차
 1. GC 상황 모니터링
  * GC 상황을 모니터링하면서 현재 운영되는 시스템의 GC 상황을 확인해야 한다.
 2. 모니터링 결과 분석 후 GC 튜닝 여부 결정
  * GC 상황을 확인한 후에는, 결과를 분석하고 GC 튜닝 여부를 결정해야 한다. 분석한 결과를 확인했는데 GC 수행에 소요된 시간이 0.1-0.3초 밖에 안 된다면 굳이 GC 튜닝에 시간을 낭비할 필요는 없다. 하지만 GC 수행 시간이 1-3초, 심지어 10초가 넘는 상황이라면 GC 튜닝을 진행해야 한다.
 3. GC 방식/메모리 크기 지정
  * GC 튜닝을 진행하기로 결정했다면 GC 방식을 선정하고 메모리의 크기를 지정한다. 이때 서버가 여러 대이면 서버에 GC 옵션을 서로 다르게 지정해서 GC 옵션에 따른 차이를 확인하는 것이 중요하다.
4. 결과 분석
 * GC 옵션을 지정하고 적어도 24시간 이상 데이터를 수집한 후에 분석을 실시한다. 운이 좋으면 해당 시스템에 가장 적합한 GC 옵션을 찾을 수 있다. 그렇지 않다면 로그를 분석해 메모리가 어떻게 할당되는지 확인해야 한다. 그 다음에 GC 방식/메모리 크기를 변경해 가면서 최적의 옵션을 찾아 나간다.
5. 결과가 만족으러울 경우 전체 서버에 반영 및 종료.

#### 1, 2 단계: GC 상황 모니터링 및 결과 분석하기
운영 중인 WAS의 GC 상황을 확인하는 가장 좋은 방법은 jstat 명령어를 사용하는 것이다.
1. YGC와 YGCT의 값을 확인한다.
 * YGCT 값을 YGC로 나눈 값이 Young 영역에서 GC가 수행되는데 소요되는 평균 시간이다.
2. FGCT와 FGC의 값을 확인한다.
 * FGCT 값을 FGC로 나눈 값이 Full GC가 수행되는데 소요되는 평균 시간이다.
 
 ###### 종합(GC가 수행되는 시간이 아래에 부합한다면 GC튜닝이 필요 없다.)
 * Minor GC의 처리 시간이 빠르다(50ms내외).
 * Minor GC 주기가 빈번하지 않다(10초 내외).
 * Full GC의 처리 시간이 빠르다(보통 1초 이내).
 * Full GC 주기가 빈번하지 않다(10분에 1회).
 
 #### 3-1단계: GC 방식 지정
 운영 중인 시스템 특성에 따라 적합한 GC 방식이 다르므로 해당 시스템에 최적인 방식을 찾아야 한다. 운영 중인 서버가 6대 정도 있다면, 2대씩 각 옵션을 동일하게 지정하고 -verbosegc 옵션을 추가한 후 결과를 분석하는 것이 좋다.
 
 #### 3-2단계: 메모리 크기
 여기서 말하는 메모리 크기는 JVM의 시작 크기(-Xms)와 최대 크기 (-Xmx)를 말한다.
 * 메모리 크기가 크면, 
   * GC 발생 횟수는 감소한다.
   * GC 수행 시간은 길어진다.
 * 메모리 크기가 작으면, 
   * GC 발생 횟수는 증가한다.
   * GC 수행 시간은 짧아진다.
 
 메모리 크기를 지정할 때 해야 하는 것이 한 가지 더 있다. 바로 NewRatio다.<br/>
 NewRatio는 New 영역과 Old 영역의 비율이다. 값이 커지면 커질수록 Old 영역의 크기가 커지고 New 영역의 크기가 작아진다.<br/>
 New 영역의 크기가 작으면 Old 영역으로 넘어가는 메모리의 양이 많아져서 Full GC도 잦아지고 시간도 오래 걸린다.
 
 #### 4단계: GC 튜닝 결과 분석
 GC 옵션을 적용하고, -verbosegc 옵션을 지정한 다음에 tail 명령어로 로그가 제대로 쌓이고 있는지 확인해야 한다. <br/>
 분석할 때는 다음의 사항을 중심으로 살펴보는 것이 좋다.
 * Full GC 수행 시간
 * Minor GC 수행 시간
 * Full GC 수행 간격
 * Minor GC 수행 간격
 * 전체 Full GC 수행 시간
 * 전체 Minor GC 수행 시간
 * 전체 GC 수행 시간
 * Full GC 수행 횟수
 * Minor GC 수행 횟수
 <hr/>
 
 ### 정리
 현재 시스템에 대한 정확한 분석 없이 GC 튜닝을 한다고 JVM 옵션을 지정했다가는 OutOfMemoryError가 발생하는 치명적인 상황으로 갈 수도 있다. 따라서, 전문가와 함께 시스템을 분석하고 튜닝 작업을 수행할 것을 권장한다. 그리고 무엇보다도 반드시 알고 있어야 하는 것이 바로 GC 튜닝은 튜닝의 가장 마지막에 하는 작업이라는 것이다. 애플리케이션에서 임시 메모리를 가장 적게 생성하도록 튜닝을 하고, 애플리케이션 성능을 측정을 한 다음에도 문제가 있을 때 GC 튜닝을 진행해야 한다.
 
 
