# Cache의 활용
Cache를 사용하면 성능을 크게 높일 수 있다. 하지만, 아무 곳에나 무분별하게 캐시를 쓴다고 해서 성능이 무조건 좋아지는 것이 아니다.

캐시를 시스템 상으로 분류
* CPU L1 Cache
* CPU L2 Cache
* Disk Cache

> 이 캐시들은 OS 및 하드웨어에서 제공하는 캐시를 말한다. 즉, 시스템의 성능을 높이는 데 사용되는 것들이다. 그런데 앞으로 이야기할 캐시는 이 레벨의 캐시가 아니다.

서비스를 개발하는 개발자들의 기준으로 보는 캐시는 다음과 같이 간단하게 분류할 수도 있다.
* 로컬 (Local) 캐시
  * 하나의 장비나 JVM 내에서 캐시 내용이 공유되는 것
  * 서로 다른 장비에 있는 데이터를 사용하기 위한 통신비용이 들지 않는 캐시
* 글로벌 (Global) 캐시
  * 다른 장비에 있는 캐시의 내용을 공유하는 것

구분 | 장점 | 단점
:----:|:----:|:----:
로컬 캐시 | 같은 JVM내 혹은 같은 장비에서 데이터를 가져오므로 성능이 좋다. | 하나의 장비 내에 있는 데이터만 동기화가 이루어진다.
글로벌 캐시 | 데이터 동기화가 실시간으로 이루어지기 때문에 모든 사용자가 동일한 데이터를 가질 수 있다. | 성능이 로컬 캐시에 비해 좋지 않다.

> 글로벌 캐시가 성능이 엄청나게 나쁜 것은 아니다.

###### 잘 알려진 캐시
이름 | 개발사 | 주 개발 언어 | 저장 방식
:----:|:-----:|:-----------:|:-------:
EHCache | TerraCotta | 자바 | Key-Value
Memcached | 오픈 소스 | C | Key-Value
Redis | 오픈소스 | C | Key-Value
MongoDB | 오픈소스 | C++ | Key-Value 및 JSON 기반
HBase | 오픈소스 | 자바 | Tabular(테이블 기반)

> Key-Value 기반의 저장 방식은 Hashtable과 같이 키와 값으로 된 저장 방식이다. MongoDB의 경우는 JSON 데이터가 저장되는 방식이다. 따라서, 지금까지의 
관계형 DBMS(RDBMS)가 고정되어 있는 형태의 저장소라면, MongoDB는 유연한 형태의 저장소라고 볼 수 있다. HBase는 테이블 기반의 저장소이지만, RDBMS의 구조와는 매우 다르다.
<hr/>

### 캐시의 선택
NoSQL 기반의 캐시를 사용할 때는 반드시 BMT(Benchmark Test)를 통해서 현재 개발하려는 시스템의 상황에 가장 잘 맞는 캐시를 선정해야 한다.

* 대용량 데이터의 경우 디스크에 저장하는데, 성능이 아주 좋은 SSD가 아닌 이상 성능이 매우 느려진다. 캐시가 오히려 성능을 저하시킬 수도 있다는 이야기다.
  * 이러한 경우에는 여러 서버에 분산하여 데이터를 저장한다.

> 그런데, 모든 캐시가 분산 환경을 제공하는 것은 아니다. Memcached에서 제공하는 기본 기능은 단독 서버에서 데이터를 제공하는 방식이며, 디스크 저장을 하지 
않고 메모리에 저장한다. 따라서 서버에 비싼 메모리를 꽂는다면 엄청난 비용이 들게 될 것이다. 따라서, 어떤 캐시를 사용할지를 선정하는 작업은 중요하다.

기본적으로 캐시에서 제공되는 기능 외에도 성능은 매우 큰 캐시 선정 요건 중에 하나이다.<br/>
> 실제 데이터가 얼마나 들어갈지를 확인해 보고, 그만큼 데이터를 넣어두고 성능을 측정해 보는 점검작업을 수행하는 것은 매우 중요하다.

###### 캐시 사용의 좋은 예
* 1분에 몇 번 로그인하는지 확인하고자 할 때
* 카페 등에서 최근에 쓴 글이 어떤 글인지 확인하고자 할 때
* CPU 사용량등과 같이 수집되는 데이터가 10만개 중 한두개 없어져도 전혀 문제 안되는 작업을 할 때
* 1분 뒤에 날아가도 되는 데이터
* RDBMS에서 데이터를 가져와도 되지만 매우 자주 사용되면서 캐시에 없으면 DB에서 가져오면 되는 것들

###### 캐시 사용의 나쁜 예
* 돈과 관련된 작업

> 성능 개선 효과가 있고, 데이터가 날아간다고 뭐라고 할 사람이 아무도 없는 경우에 사용
<hr/>

### Key-Value Cache
Hashtable과 같은 Map 구조

###### Memcached
* 메모리 기반
  * 캐시 프로세스가 종료되면 캐시 내부에 있는 데이터는 모두 사라진다.
* 명령어
  * set
    * 데이터를 추가하며, 기존 데이터가 있을 경우 수정한다.
  * add
    * 기존 데이터가 없을 경우에만 추가한다.
  * replace
    * 기존 데이터가 있을 경우에만 수정한다.
  * append
    * 기존 데이터의 가장 뒤에 해당 데이터를 붙인다.
  * prepent
    * 기존 데이터의 가장 뒤에 해당 데이터를 붙인다. 만약 기존 데이터가 없으면 추가한다.
  * cas
    * Check And Set(혹은 Compare And Swap)의 약자로 전에 읽은 후에 변경이 없을 경우에만 데이터를 업데이트 한다.
  * get
    * 데이터를 조회한다.
  * gets
    * cas를 이용한 get이다. 데이터와 함께 cas 식별 값을 받는다.
  * delete
    * 데이터를 삭제한다.
  * incr/decr
    * 64 비트 값을 증가하고 감소한다. 단, 이 값은 음수를 허용하지 않는다.

> 이러한 Memcached는 기본적으로 데이터를 저장할 때 수명을 지정한다. 살아 있는 주기만 지정해 주면 알아서 캐시에서 없어진다.
<hr/>

### 테이블 기반의 저장소인 HBase
요즘 인기 있는 캐시 저장소 중 하나.
* 진입 장벽이 높다. 윈도에서 설치하는 것이 까다롭고, 데이터 저장소의 구조가 지금까지 봐온 데이터 구조와 매우 다르다.

###### HBase 테이블 구조
Row Key | Time Stamp | ColumnFamily contents | ColumnFamily anchor
:------:|:------------:|:--------------------:|:---------------------:

HBase에서 어떤 데이터를 가져오려면 Row Key라는 값을 알고 있어야 한다. Map의 구조에서 '키'의 역할을 하는 것이라고 보면 된다. 그리고, 데이터가 저장된 
순서에 따라서 Time Stamp(TS)라는 값이 지정된다. 같은 Row Key를 갖는다고 하더라도, TS가 다르면 서로 다른 값을 가져오게 된다. 그리고, contents와 
auchor라는 두개의 ColumnFamily라는 것이 존재한다. 동일한 ColumnFamily에는 같은 의미를 갖는 데이터들이 들어간다고 생각하면 된다. 그리고 ColumnFamily 
뒤에 콜론(:)붙인 뒤에 나오는 단어는 qualifier라고 부른다.

* Table 내에 Row Key와 TS는 필수로 존재하며, 저장하고자 하는 데이터는 ColumnFamily로 정의한다.
* HBase의 테이블을 선언할 때는 하나의 ColumnFamily에는 qualifier로 구분된 여러 가지 데이터들이 저장된다. 여기서 qualifier는 미리 정의할 필요가 없으며, 
필요할 때마다 지정하여 사용하면 된다.
* 명령어
  * Get: 하나의 Row 데이터 읽기
  * Put: 데이터를 저장
  * Scan: 하나 이상의 Row의 데이터 읽기
  * Delete: 하나의 Row를 테이블에서 삭제

> 매우 유연한 HBase는 Key-Value 기반의 NoSql에 비하여 다양한 데이터를 저장할 수 있으며, 성능도 매우 빠르다.


